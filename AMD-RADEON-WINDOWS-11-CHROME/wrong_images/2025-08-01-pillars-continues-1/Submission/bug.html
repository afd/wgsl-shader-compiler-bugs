<!--
Copyright 2025 The wgsl-fuzz Project Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>wgsl-fuzz Worker</title>
    <style>
      body {
        font-family: system-ui, sans-serif;
        padding: 2rem;
        background-color: #fafafa;
        color: #333;
        line-height: 1.6;
      }

      h1 {
        font-size: 1.8rem;
        margin-bottom: 1rem;
      }

      canvas {
        display: block;
        border: 1px solid #ccc;
        margin-top: 1rem;
      }

      pre#output {
        margin-top: 1.5rem;
        padding: 1rem;
        background-color: #f0f0f0;
        border-radius: 6px;
        white-space: pre-wrap;
        word-break: break-word;
      }
    </style>
  </head>
  <body>
    <main>
      <h1>wgsl-fuzz Worker</h1>
      <canvas
        id="thecanvas"
        width="256"
        height="256"
        aria-label="WebGPU rendering canvas"
      ></canvas>
      <pre id="output" aria-live="polite"></pre>
    </main>

    <script>
      /*
       * Copyright 2025 The wgsl-fuzz Project Authors
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     https://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      function canvasToPngJson(canvas) {
        const [_, base64Data] = canvas.toDataURL("image/png").split(",", 2);
        return {
          type: "image/png",
          encoding: "base64",
          data: base64Data,
        };
      }

      async function renderImage(job, device, canvas, canvasFormat, context) {
        const vertices = new Float32Array([
          -1.0,
          -1.0, // Triangle 1
          1.0,
          -1.0,
          1.0,
          1.0,

          -1.0,
          -1.0, // Triangle 2
          1.0,
          1.0,
          -1.0,
          1.0,
        ]);

        const vertexBuffer = device.createBuffer({
          label: "Vertices",
          size: vertices.byteLength,
          usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        });

        device.queue.writeBuffer(vertexBuffer, /*bufferOffset=*/ 0, vertices);

        const vertexBufferLayout = {
          arrayStride: 8,
          attributes: [
            {
              format: "float32x2",
              offset: 0,
              shaderLocation: 0, // 'position' in vertex shader
            },
          ],
        };

        device.pushErrorScope("validation");
        device.pushErrorScope("out-of-memory");
        device.pushErrorScope("internal");
        const shaderModule = device.createShaderModule({
          label: "Shader",
          code: job.shaderText,
        });
        const createShaderModuleErrorsInternal = device.popErrorScope();
        const createShaderModuleErrorsOutOfMemory = device.popErrorScope();
        const createShaderModuleErrorsValidation = device.popErrorScope();

        device.pushErrorScope("validation");
        device.pushErrorScope("out-of-memory");
        device.pushErrorScope("internal");
        const uniformBufferBindingsOnDeviceByGroup = new Map();
        var maxBindGroup = 0;
        for (const uniformBufferForJob of job.uniformBuffers) {
          const length = uniformBufferForJob.data.length;
          const group = uniformBufferForJob.group;
          const binding = uniformBufferForJob.binding;
          maxBindGroup = Math.max(group, maxBindGroup);
          const uniformArray = new Uint8Array(Math.max(length, 16)); // 16 is minimum binding size - is this fixed?
          for (let i = 0; i < length; i++) {
            uniformArray[i] = uniformBufferForJob.data[i];
          }
          const uniformBufferOnDevice = device.createBuffer({
            label: "Uniform buffer, group " + group + ", binding " + binding,
            size: uniformArray.byteLength,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
          });
          device.queue.writeBuffer(uniformBufferOnDevice, 0, uniformArray);
          if (!uniformBufferBindingsOnDeviceByGroup.has(group)) {
            uniformBufferBindingsOnDeviceByGroup.set(group, []);
          }
          uniformBufferBindingsOnDeviceByGroup.get(group).push({
            binding: binding,
            resource: {
              buffer: uniformBufferOnDevice,
            },
          });
        }

        const pipeline = device.createRenderPipeline({
          label: "Pipeline",
          layout: "auto",
          vertex: {
            module: shaderModule,
            entryPoint: "vertexMain",
            buffers: [vertexBufferLayout],
          },
          fragment: {
            module: shaderModule,
            entryPoint: "fragmentMain",
            targets: [
              {
                format: canvasFormat,
              },
            ],
          },
        });

        const encoder = device.createCommandEncoder();

        const pass = encoder.beginRenderPass({
          colorAttachments: [
            {
              view: context.getCurrentTexture().createView(),
              loadOp: "clear",
              clearValue: { r: 0.5, g: 0, b: 0.5, a: 1.0 },
              storeOp: "store",
            },
          ],
        });

        pass.setPipeline(pipeline);
        pass.setVertexBuffer(0, vertexBuffer);

        for (let i = 0; i <= maxBindGroup; i++) {
          if (!uniformBufferBindingsOnDeviceByGroup.has(i)) {
            continue;
          }
          const entries = uniformBufferBindingsOnDeviceByGroup.get(i);
          const bindGroup = device.createBindGroup({
            label: "Bind group " + i,
            layout: pipeline.getBindGroupLayout(i),
            entries: entries,
          });
          pass.setBindGroup(i, bindGroup);
        }

        pass.draw(vertices.length / 2);
        pass.end();

        device.queue.submit([encoder.finish()]);

        const compilationInfo = await shaderModule.getCompilationInfo();

        vertexBuffer.destroy();

        const otherErrorsInternal = device.popErrorScope();
        const otherErrorsOutOfMemory = device.popErrorScope();
        const otherErrorsValidation = device.popErrorScope();

        const renderImageResult = {
          compilationMessages: compilationInfo.messages.map((message) => ({
            message: message.message,
            type: message.type.toString(),
            lineNum: message.lineNum,
            linePos: message.linePos,
            offset: message.offset,
            length: message.length,
          })),
        };

        var errorOccurred = false;

        await createShaderModuleErrorsInternal.then((error) => {
          if (error) {
            renderImageResult.createShaderModuleInternalError = error.message;
            errorOccurred = true;
          }
        });

        await createShaderModuleErrorsOutOfMemory.then((error) => {
          if (error) {
            renderImageResult.createShaderModuleOutOfMemoryError =
              error.message;
            errorOccurred = true;
          }
        });

        await createShaderModuleErrorsValidation.then((error) => {
          if (error) {
            renderImageResult.createShaderModuleValidationError = error.message;
            errorOccurred = true;
          }
        });

        await otherErrorsInternal.then((error) => {
          if (error) {
            renderImageResult.otherInternalError = error.message;
            errorOccurred = true;
          }
        });

        await otherErrorsOutOfMemory.then((error) => {
          if (error) {
            renderImageResult.otherOutOfMemoryError = error.message;
            errorOccurred = true;
          }
        });

        await otherErrorsValidation.then((error) => {
          if (error) {
            renderImageResult.otherValidationError = error.message;
            errorOccurred = true;
          }
        });

        if (!errorOccurred) {
          renderImageResult.frame = canvasToPngJson(canvas);
        }

        return renderImageResult;
      }

      function clearCanvas(device, context) {
        const encoder = device.createCommandEncoder();
        const pass = encoder.beginRenderPass({
          colorAttachments: [
            {
              view: context.getCurrentTexture().createView(),
              loadOp: "clear",
              clearValue: { r: 0, g: 0, b: 0.4, a: 1 },
              storeOp: "store",
            },
          ],
        });
        pass.end();
        device.queue.submit([encoder.finish()]);
      }

      async function executeJob(job, repetitions) {
        const canvas = document.querySelector("canvas");

        if (!navigator.gpu) {
          throw new Error("WebGPU not supported on this browser.");
        }

        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
          throw new Error("No appropriate GPUAdapter found.");
        }

        const adapterInfo = adapter.info;

        var jobResult = {
          adapterInfo: {
            vendor: adapterInfo.vendor,
            architecture: adapterInfo.architecture,
            device: adapterInfo.device,
            description: adapterInfo.description,
          },
          renderImageResults: [],
        };

        const device = await adapter.requestDevice();

        var uncapturedErrors = [];

        device.addEventListener("uncapturederror", (event) => {
          console.error("A WebGPU error was not captured: ", event.error);
          uncapturedErrors.push(event.error.message);
        });

        const context = canvas.getContext("webgpu");
        const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
        context.configure({
          device: device,
          format: canvasFormat,
        });

        for (var i = 0; i < repetitions; i++) {
          clearCanvas(device, context);
          jobResult.renderImageResults.push(
            await renderImage(job, device, canvas, canvasFormat, context)
          );
        }

        device.destroy();

        return jobResult;
      }

      const shaderText = `
        const DP_LENGTH  = 256;
        
        @group(0)
        @binding(0)
        var<uniform> resolution : vec2<i32>;
        
        @group(0)
        @binding(1)
        var<uniform> dpInput : array<vec4<i32>, DP_LENGTH / 8>;
        
        var<private> dp : array<i32, DP_LENGTH>;
        
        fn trace(
            posInitial : vec2i,
        ) -> vec4f
        {
            var pos : vec2i = posInitial;
            while (pos.y != 256)
            {
                /* The "resolution" uniform is set to (256, 256), so this condition is guaranteed to be false and the continue will not be executed */
                if (resolution[1] > 1000000)
                {
                    continue;
                }
                if (pos.x < dp[pos.y] + 15 && pos.x > dp[pos.y] - 15)
                {
                    let p = (15.0 - abs(f32(pos.x - dp[pos.y], ), )) / 15.0;
                    /* Again, because "resolution" is (256, 256) this condition will be false and the continue will not be executed */
                    if (resolution[1] != 256)
                    {
                        continue;
                    }
                    return vec4(p, p, p, 1, );
                }
                pos.y++;
            }
            return vec4(0, 0, 0, 1, );
        }
        
        @vertex
        fn vertexMain(
            @location(0)
            pos : vec2f,
        ) ->
                @builtin(position)
            vec4f
        {
            return vec4f(pos, 0, 1, );
        }
        
        fn getBottomHalf(
            num : i32,
        ) -> i32
        {
            return num & 0xFFFF;
        }
        
        fn getTopHalf(
            num : i32,
        ) -> i32
        {
            return (num >> 16) & 0xFFFF;
        }
        
        @fragment
        fn fragmentMain(
            @builtin(position)
            gl_FragCoord : vec4f,
        ) ->
                @location(0)
            vec4f
        {
            for (var i = 0; i < DP_LENGTH / 8; i++)
            {
                let index = 8 * i;
                dp[index] = getBottomHalf(dpInput[i].x, );
                dp[index + 1] = getTopHalf(dpInput[i].x, );
                dp[index + 2] = getBottomHalf(dpInput[i].y, );
                dp[index + 3] = getTopHalf(dpInput[i].y, );
                dp[index + 4] = getBottomHalf(dpInput[i].z, );
                dp[index + 5] = getTopHalf(dpInput[i].z, );
                dp[index + 6] = getBottomHalf(dpInput[i].w, );
                dp[index + 7] = getTopHalf(dpInput[i].w, );
            }
            let pos = gl_FragCoord.xy / vec2<f32>(resolution, );
            let ipos : vec2i = vec2i(pos * vec2(256, 256, ), );
            return trace(ipos, );
        }
      `;

      const uniformBuffers = [
        {
          group: 0,
          binding: 0,
          data: [0, 1, 0, 0, 0, 1, 0, 0],
        },
        {
          group: 0,
          binding: 1,
          data: [
            115, 0, 133, 0, 150, 0, 164, 0, 176, 0, 184, 0, 190, 0, 192, 0, 191,
            0, 187, 0, 181, 0, 172, 0, 163, 0, 153, 0, 143, 0, 134, 0, 126, 0,
            120, 0, 116, 0, 114, 0, 114, 0, 117, 0, 121, 0, 127, 0, 134, 0, 141,
            0, 148, 0, 154, 0, 159, 0, 162, 0, 163, 0, 161, 0, 157, 0, 151, 0,
            143, 0, 134, 0, 124, 0, 113, 0, 103, 0, 94, 0, 87, 0, 82, 0, 79, 0,
            80, 0, 84, 0, 91, 0, 101, 0, 114, 0, 130, 0, 146, 0, 164, 0, 182, 0,
            199, 0, 215, 0, 229, 0, 240, 0, 249, 0, 254, 0, 0, 1, 254, 0, 250,
            0, 243, 0, 233, 0, 223, 0, 212, 0, 200, 0, 190, 0, 180, 0, 172, 0,
            166, 0, 163, 0, 161, 0, 162, 0, 164, 0, 169, 0, 174, 0, 179, 0, 185,
            0, 190, 0, 193, 0, 195, 0, 195, 0, 192, 0, 188, 0, 180, 0, 171, 0,
            161, 0, 149, 0, 137, 0, 125, 0, 114, 0, 105, 0, 97, 0, 93, 0, 91, 0,
            93, 0, 98, 0, 106, 0, 117, 0, 130, 0, 145, 0, 161, 0, 177, 0, 193,
            0, 208, 0, 221, 0, 231, 0, 239, 0, 243, 0, 244, 0, 242, 0, 236, 0,
            228, 0, 218, 0, 207, 0, 194, 0, 181, 0, 169, 0, 158, 0, 148, 0, 141,
            0, 135, 0, 132, 0, 131, 0, 132, 0, 135, 0, 138, 0, 143, 0, 147, 0,
            151, 0, 154, 0, 155, 0, 155, 0, 152, 0, 146, 0, 139, 0, 129, 0, 118,
            0, 106, 0, 93, 0, 80, 0, 68, 0, 58, 0, 49, 0, 43, 0, 40, 0, 41, 0,
            44, 0, 51, 0, 61, 0, 73, 0, 87, 0, 103, 0, 119, 0, 134, 0, 149, 0,
            162, 0, 173, 0, 181, 0, 186, 0, 188, 0, 186, 0, 181, 0, 174, 0, 164,
            0, 153, 0, 141, 0, 128, 0, 116, 0, 104, 0, 94, 0, 86, 0, 81, 0, 77,
            0, 76, 0, 77, 0, 80, 0, 84, 0, 89, 0, 94, 0, 98, 0, 102, 0, 104, 0,
            104, 0, 102, 0, 98, 0, 92, 0, 83, 0, 73, 0, 62, 0, 50, 0, 38, 0, 26,
            0, 16, 0, 8, 0, 2, 0, 0, 0, 0, 0, 4, 0, 11, 0, 21, 0, 33, 0, 48, 0,
            64, 0, 81, 0, 98, 0, 114, 0, 129, 0, 141, 0, 151, 0, 158, 0, 161, 0,
            161, 0, 158, 0, 152, 0, 144, 0, 134, 0, 123, 0, 112, 0, 100, 0, 90,
            0, 81, 0, 73, 0, 68, 0, 65, 0, 65, 0, 67, 0, 70, 0, 75, 0, 81, 0,
            87, 0, 92, 0, 97, 0, 101, 0, 103, 0, 102, 0, 100, 0, 95, 0, 88, 0,
            79, 0, 69, 0, 58, 0, 47, 0, 36, 0, 26, 0, 18, 0, 13, 0, 11, 0, 11,
            0, 15, 0, 22, 0, 32, 0, 45, 0, 60, 0, 77, 0, 94, 0,
          ],
        },
      ];

      const job = {
        shaderText,
        uniformBuffers,
      };

      async function main() {
        const result = await executeJob(job, 1);

        console.log(result);
      }

      main();
    </script>
  </body>
</html>
