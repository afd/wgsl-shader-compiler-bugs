<!--
Copyright 2025 The wgsl-fuzz Project Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>wgsl-fuzz Worker</title>
    <style>
      body {
        font-family: system-ui, sans-serif;
        padding: 2rem;
        background-color: #fafafa;
        color: #333;
        line-height: 1.6;
      }

      h1 {
        font-size: 1.8rem;
        margin-bottom: 1rem;
      }

      canvas {
        display: block;
        border: 1px solid #ccc;
        margin-top: 1rem;
      }

      pre#output {
        margin-top: 1.5rem;
        padding: 1rem;
        background-color: #f0f0f0;
        border-radius: 6px;
        white-space: pre-wrap;
        word-break: break-word;
      }
    </style>
  </head>
  <body>
    <main>
      <h1>wgsl-fuzz Worker</h1>
      <canvas
        id="thecanvas"
        width="256"
        height="256"
        aria-label="WebGPU rendering canvas"
      ></canvas>
      <pre id="output" aria-live="polite"></pre>
    </main>

    <script type="module">
      /*
       * Copyright 2025 The wgsl-fuzz Project Authors
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     https://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       */

      function canvasToPngJson(canvas) {
        const [, base64Data] = canvas.toDataURL("image/png").split(",", 2);
        return {
          type: "image/png",
          encoding: "base64",
          data: base64Data,
        };
      }

      async function renderImage(job, device, canvas) {
        const vertices = new Float32Array([
          -1.0,
          -1.0, // Triangle 1
          1.0,
          -1.0,
          1.0,
          1.0,

          -1.0,
          -1.0, // Triangle 2
          1.0,
          1.0,
          -1.0,
          1.0,
        ]);

        const renderTarget = device.createTexture({
          size: [canvas.width, canvas.height],
          format: "rgba8unorm",
          usage:
            GPUTextureUsage.RENDER_ATTACHMENT |
            GPUTextureUsage.TEXTURE_BINDING |
            GPUTextureUsage.COPY_SRC,
        });

        const renderTargetView = renderTarget.createView();

        const vertexBuffer = device.createBuffer({
          label: "Vertices",
          size: vertices.byteLength,
          usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        });

        device.queue.writeBuffer(vertexBuffer, /*bufferOffset=*/ 0, vertices);

        const vertexBufferLayout = {
          arrayStride: 8,
          attributes: [
            {
              format: "float32x2",
              offset: 0,
              shaderLocation: 0, // 'position' in vertex shader
            },
          ],
        };

        device.pushErrorScope("validation");
        device.pushErrorScope("out-of-memory");
        device.pushErrorScope("internal");
        const shaderModule = device.createShaderModule({
          label: "Shader",
          code: job.shaderText,
        });
        const createShaderModuleErrorsInternal = device.popErrorScope();
        const createShaderModuleErrorsOutOfMemory = device.popErrorScope();
        const createShaderModuleErrorsValidation = device.popErrorScope();

        device.pushErrorScope("validation");
        device.pushErrorScope("out-of-memory");
        device.pushErrorScope("internal");
        const uniformBufferBindingsOnDeviceByGroup = new Map();
        var maxBindGroup = 0;
        for (const uniformBufferForJob of job.uniformBuffers) {
          const length = uniformBufferForJob.data.length;
          const group = uniformBufferForJob.group;
          const binding = uniformBufferForJob.binding;
          maxBindGroup = Math.max(group, maxBindGroup);
          const uniformArray = new Uint8Array(Math.max(length, 16)); // 16 is minimum binding size - is this fixed?
          for (let i = 0; i < length; i++) {
            uniformArray[i] = uniformBufferForJob.data[i];
          }
          const uniformBufferOnDevice = device.createBuffer({
            label: "Uniform buffer, group " + group + ", binding " + binding,
            size: uniformArray.byteLength,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
          });
          device.queue.writeBuffer(uniformBufferOnDevice, 0, uniformArray);
          if (!uniformBufferBindingsOnDeviceByGroup.has(group)) {
            uniformBufferBindingsOnDeviceByGroup.set(group, []);
          }
          uniformBufferBindingsOnDeviceByGroup.get(group).push({
            binding: binding,
            resource: {
              buffer: uniformBufferOnDevice,
            },
          });
        }

        const pipeline = device.createRenderPipeline({
          label: "Pipeline",
          layout: "auto",
          vertex: {
            module: shaderModule,
            entryPoint: "vertexMain",
            buffers: [vertexBufferLayout],
          },
          fragment: {
            module: shaderModule,
            entryPoint: "fragmentMain",
            targets: [
              {
                format: "rgba8unorm",
              },
            ],
          },
        });

        const renderToTextureEncoder = device.createCommandEncoder({
          label: "Render to texture encoder",
        });

        const pass = renderToTextureEncoder.beginRenderPass({
          label: "Render pass",
          colorAttachments: [
            {
              view: renderTargetView,
              clearValue: { r: 0.5, g: 0, b: 0.5, a: 1.0 },
              loadOp: "clear",
              storeOp: "store",
            },
          ],
        });

        pass.setPipeline(pipeline);
        pass.setVertexBuffer(0, vertexBuffer);

        for (let i = 0; i <= maxBindGroup; i++) {
          if (!uniformBufferBindingsOnDeviceByGroup.has(i)) {
            continue;
          }
          const entries = uniformBufferBindingsOnDeviceByGroup.get(i);
          const bindGroup = device.createBindGroup({
            label: "Bind group " + i,
            layout: pipeline.getBindGroupLayout(i),
            entries: entries,
          });
          pass.setBindGroup(i, bindGroup);
        }

        pass.draw(vertices.length / 2);
        pass.end();

        device.queue.submit([renderToTextureEncoder.finish()]);

        const compilationInfo = await shaderModule.getCompilationInfo();

        vertexBuffer.destroy();

        const otherErrorsInternal = device.popErrorScope();
        const otherErrorsOutOfMemory = device.popErrorScope();
        const otherErrorsValidation = device.popErrorScope();

        const renderImageResult = {
          compilationMessages: compilationInfo.messages.map((message) => ({
            message: message.message,
            type: message.type.toString(),
            lineNum: message.lineNum,
            linePos: message.linePos,
            offset: message.offset,
            length: message.length,
          })),
        };

        var errorOccurred = false;

        await createShaderModuleErrorsInternal.then((error) => {
          if (error) {
            renderImageResult.createShaderModuleInternalError = error.message;
            errorOccurred = true;
          }
        });

        await createShaderModuleErrorsOutOfMemory.then((error) => {
          if (error) {
            renderImageResult.createShaderModuleOutOfMemoryError =
              error.message;
            errorOccurred = true;
          }
        });

        await createShaderModuleErrorsValidation.then((error) => {
          if (error) {
            renderImageResult.createShaderModuleValidationError = error.message;
            errorOccurred = true;
          }
        });

        await otherErrorsInternal.then((error) => {
          if (error) {
            renderImageResult.otherInternalError = error.message;
            errorOccurred = true;
          }
        });

        await otherErrorsOutOfMemory.then((error) => {
          if (error) {
            renderImageResult.otherOutOfMemoryError = error.message;
            errorOccurred = true;
          }
        });

        await otherErrorsValidation.then((error) => {
          if (error) {
            renderImageResult.otherValidationError = error.message;
            errorOccurred = true;
          }
        });

        if (!errorOccurred) {
          const copyFromTextureEncoder = device.createCommandEncoder({
            label: "Copy from texture encoder",
          });
          const outputBuffer = device.createBuffer({
            size: canvas.width * canvas.height * 4, // 4 bytes per pixel
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
          });
          copyFromTextureEncoder.copyTextureToBuffer(
            { texture: renderTarget },
            {
              buffer: outputBuffer,
              bytesPerRow: canvas.width * 4,
              rowsPerImage: canvas.height,
            },
            {
              width: canvas.width,
              height: canvas.height,
              depthOrArrayLayers: 1,
            }
          );
          device.queue.submit([copyFromTextureEncoder.finish()]);
          await outputBuffer.mapAsync(GPUMapMode.READ);
          const arrayBuffer = outputBuffer.getMappedRange();
          const pixelBytes = new Uint8Array(arrayBuffer.slice(0)); // Copy it out
          outputBuffer.unmap();

          const imageData = new ImageData(
            new Uint8ClampedArray(pixelBytes), // must be Uint8ClampedArray
            canvas.width,
            canvas.height
          );
          const context = canvas.getContext("2d");
          context.putImageData(imageData, 0, 0);
          renderImageResult.frame = canvasToPngJson(canvas);
        }

        return renderImageResult;
      }

      export async function executeJob(job, repetitions) {
        const jobResult = {
          fatalErrors: [],
          deviceLostReason: null,
          adapterInfo: null,
          renderImageResults: [],
        };

        const canvas = document.querySelector("canvas");

        if (!navigator.gpu) {
          jobResult.fatalErrors.push("WebGPU not supported on this browser.");
          return jobResult;
        }

        let adapter;
        try {
          adapter = await navigator.gpu.requestAdapter();
        } catch (err) {
          jobResult.fatalErrors.push(
            `Failed to request GPU adapter: ${err?.message || String(err)}`
          );
          return jobResult;
        }

        if (!adapter) {
          jobResult.fatalErrors.push("No appropriate GPUAdapter found.");
          return jobResult;
        }

        const adapterInfo = adapter.info;
        jobResult.adapterInfo = {
          vendor: adapterInfo.vendor,
          architecture: adapterInfo.architecture,
          device: adapterInfo.device,
          description: adapterInfo.description,
        };

        let device;
        try {
          device = await adapter.requestDevice();
        } catch (err) {
          jobResult.fatalErrors.push(
            `Failed to request device: ${err?.message || String(err)}`
          );
          return jobResult;
        }

        let destroyCalledExplicitly = false;

        device.lost.then((info) => {
          if (!destroyCalledExplicitly) {
            jobResult.deviceLostReason = info.reason;
            jobResult.fatalErrors.push(`Device lost: ${info.message}`);
          }
        });

        device.addEventListener("uncapturederror", (event) => {
          console.error("A WebGPU error was not captured: ", event.error);
          jobResult.fatalErrors.push(event.error.message);
        });

        for (let i = 0; i < repetitions; i++) {
          if (jobResult.fatalErrors.length > 0) {
            break;
          }
          try {
            jobResult.renderImageResults.push(
              await renderImage(job, device, canvas)
            );
          } catch (err) {
            jobResult.fatalErrors.push(err?.message || String(err));
          }
        }

        if (jobResult.deviceLostReason != "destroyed") {
          try {
            // Record that we are intentionally destroying the device, so that we do
            // not record this (expected) destruction event as a reason for device
            // loss
            destroyCalledExplicitly = true;
            device.destroy();
          } catch (err) {
            jobResult.fatalErrors.push(err?.message || String(err));
          }
        }

        return jobResult;
      }

      const shaderText = `
  const DP_LENGTH  = 256;
  
  @group(0)
  @binding(0)
  var<uniform> resolution : vec2<i32>;
  
  @group(0)
  @binding(1)
  var<uniform> dpInput : array<vec4<i32>, DP_LENGTH / 8>;
  
  var<private> dp : array<i32, DP_LENGTH>;
  
  fn trace(
      posInitial : vec2i,
  ) -> vec4f
  {
      var pos : vec2i = posInitial;
      while (pos.y != 256)
      {
          if (pos.x < dp[pos.y] + 15 && pos.x > dp[pos.y] - 15)
          {
              let p = (15.0 - abs(f32(pos.x - dp[pos.y], ), )) / 15.0;
              return vec4(p, p, p, 1, );
          }
          pos.y++;
      }
      return vec4(0, 0, 0, 1, );
  }
  
  @vertex
  fn vertexMain(
      @location(0)
      pos : vec2f,
  ) ->
          @builtin(position)
      vec4f
  {
      return vec4f(pos, 0, 1, );
  }
  
  fn getBottomHalf(
      num : i32,
  ) -> i32
  {
      return num & 0xFFFF;
  }
  
  fn getTopHalf(
      num : i32,
  ) -> i32
  {
      /* control flow wrapped 135: */
      switch (resolution.x) // resolution.x == 256
      {
          case 16442376, 15450735, 16286033, 
          {
              /* arbitrary compound: */
              /* dead code fragment: */
              if ((true) && (false))
              {
                  discard;
              }
              else
              {
              }
              let j_155 = (1574411189i);
              let i_156 = (i32((1829092628u), ));
              var p_154 = vec2(1i, 1i, );
              var canWalk_157 = (((insertBits((countLeadingZeros(((-23163810i) | (dpInput[6][1])), )), (1555418427i), (2u), (29u), )) + (dp[178])) >= (-(clamp((-353274310i), ((1206003i) + (787261i)), ((16722376i) - ((20i) + ((resolution[0]) - ((dpInput[31][1]) - (2096930i))) * ((resolution[1]) - ((10i) + ((13915078i) - (13915055i)))))), ))));
              /* dead code fragment: */
              for (; (((dpInput[4][0]) - ((((dpInput[17][3]) + ((1314000i) + (5370003i))) + (resolution[0])) + (resolution[1]))) > resolution[0]); )
              {
                  discard;
              }
              p_154.x = j_155 * 2;
              /* dead code fragment: */
              while ((((resolution[1]) + (8666512i)) - (8666512i)) > resolution[1])
              {
                  discard;
              }
              p_154.y = i_156 * 2;
              canWalk_157 = true;
          }
          case 13995525, 12065865, 
          {
              /* arbitrary compound: */
              let gl_FragCoord_159 = vec4(1.0f, 1.0f, 1.0f, 1.0f, );
              /* dead code fragment: */
              while ((!((!(false)) || ((resolution[0]) >= (reverseBits((1506607330i), ))))) && ((u32((max((resolution[1]), (countLeadingZeros((1538659490i), )), )), )) < ((extractBits((clamp((insertBits((3329043457u), (3589359657u), (12u), (u32((dpInput[12][3]), ) - (12648608u)), )), (8164963u), (13427588u), )), (0u), (((7u) * (u32((resolution[1]), ) - ((u32((resolution[0]), ) + (2616659u)) - (2616663u))) + ((1u) + (((14068526u) - ((8432336u) + u32((dpInput[21][1]), ))) + (0u)))) + (2u)), )) + (abs((insertBits((562949468u), (dot4U8Packed((1578429812u), (1172431172u), )), (0u), ((u32((resolution[1]), ) - (u32((resolution[1]), ) - (2u))) * (12u) + (u32((resolution[1]), ) - (251u))), )), )))))
              {
                  discard;
              }
              let resolution_160 = vec2(1i, 1i, );
              var map_163 = array(1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, );
              /* dead code fragment: */
              loop
              {
                  if ((((!(false)) && (true)) && ((firstTrailingBit((countLeadingZeros((2840165875u), )), )) > (firstLeadingBit((countLeadingZeros((2426087302u), )), )))) || (resolution[1] <= ((5304021i) - (5303765i))))
                  {
                      break;
                  }
                  discard;
              }
              let pos_158 = gl_FragCoord_159.xy / vec2(f32(resolution_160.x, ), f32(resolution_160.y, ), );
              let ipos_161 = vec2(i32(pos_158.x * 16, ), i32(pos_158.y * 16, ), );
              for (var i_162 = 0; i_162 < 16 * 16; i_162++)
              {
                  /* dead code fragment: */
                  if (!(!((false) && (resolution[1] > ((((4154861i) + (resolution[1])) - (4154935i)) + ((dpInput[6][3]) - ((resolution[1]) + ((((((dpInput[20][2]) - (8831550i)) + (resolution[1])) + (resolution[0])) + ((resolution[1]) + ((dpInput[20][2]) - (7144538i)))) * (3i) + (3491467i)))))))))
                  {
                      discard;
                  }
                  else
                  {
                  }
                  map_163[i_162] = 0;
                  /* dead code fragment: */
                  loop
                  {
                      if (!(dpInput[12][0] < ((((dpInput[0][0]) + ((dpInput[21][0]) - (2358230i))) - ((dpInput[29][1]) - (6532233i))) - (6074577i))))
                      {
                          break;
                      }
                      discard;
                      continuing
                      {
                      }
                  }
              }
              var p_164 = vec2<i32>(0, 0, );
              /* dead code fragment: */
              if (((((dpInput[5][2]) + (((dpInput[25][3]) - ((10101757i) - (((6779953i) + ((dpInput[25][2]) - ((5694420i) + (resolution[1])))) + (resolution[0])))) + (dpInput[25][1]))) - ((401165i) + (15617687i))) + ((13i) + ((resolution[0]) - ((1696598i) - (1696352i)))) * ((106243i) - (((5i) * (8218i) + (((dpInput[15][0]) - (8843703i)) + (resolution[1]))) + ((dpInput[12][2]) - ((2101604i) + (dpInput[20][3])))))) == resolution[1])
              {
              }
              else
              {
                  discard;
              }
              var canWalk_165 = true;
              /* dead code fragment: */
              if ((((dpInput[0][1]) - ((13684498i) - (2936444i))) + (((resolution[0]) + ((9187383i) + (((dpInput[1][0]) - (361541i)) - ((11112029i) - (5761324i))))) - ((15730560i) + (resolution[1])))) != dpInput[24][2])
              {
                  discard;
              }
              var v_166 = 0;
              /* dead code fragment: */
              if (!(dpInput[31][3] < (6160461i)))
              {
              }
              else
              {
                  discard;
              }
              while (canWalk_165)
              {
                  /* dead code fragment: */
                  if ((resolution[1] >= ((193i) + (63i))) || ((dpInput[15][2]) == (max((-1774383031i), (firstTrailingBit((482235010i), )), ))))
                  {
                  }
                  else
                  {
                      discard;
                  }
                  v_166++;
                  /* dead code fragment: */
                  while (resolution[1] > ((resolution[0])))
                  {
                      discard;
                  }
                  var direction_167 = 0;
                  if (p_164.x > 0 && map_163[(p_164.x - 2) + p_164.y * 16] == 0)
                  {
                      direction_167++;
                  }
                  if (p_164.y > 0 && map_163[p_164.x + (p_164.y - 2) * 16] == 0)
                  {
                      /* dead code fragment: */
                      if ((!(((2146770362u) < (insertBits(((3810146624u) & (2701461694u)), (3228179480u), (0u), (27u), ))) || ((256i) == resolution[1]))) && ((!((993484973u) <= (max(((countOneBits((((insertBits((2021581910u), (2449549703u), (10u), (22u), )) % ((98895u) + (u32((resolution[1]), ) + (571913u)))) % (2834063u)), )) & (reverseBits((abs((2212253908u), )), ))), (816691652u), )))) || ((true) && ((canWalk_165) && (((firstLeadingBit((3390858424u), )) & (133450181u)) < (firstLeadingBit((2155108511u), )))))))
                      {
                          discard;
                      }
                      direction_167++;
                      /* dead code fragment: */
                      if (((10884365i) - (((((1991635i) + ((dpInput[1][3]) - (8781965i)) * ((9651766i) - ((1184430i) + ((5371516i) - ((dpInput[3][3]) - (6830619i)))))) - ((resolution[0]) + (15603905i))) + ((resolution[1]) + (4071560i))) + ((((resolution[1]) + (14479824i)) - (13761729i)) * (3i) + (((resolution[1]) + (51742i)) * ((0i) + ((2i) + (1i))) + ((5749i) + (18438i)))))) <= dpInput[27][3])
                      {
                      }
                      else
                      {
                          discard;
                      }
                  }
                  /* dead code fragment: */
                  for (; ((((61i) * ((0i) + (2i)) + (28i)) + (106i)) < resolution[1]); )
                  {
                      discard;
                  }
                  if (p_164.x < 14 && map_163[(p_164.x + 2) + p_164.y * 16] == 0)
                  {
                      direction_167++;
                  }
                  if (p_164.y < 14 && map_163[p_164.x + (p_164.y + 2) * 16] == 0)
                  {
                      /* dead code fragment: */
                      loop
                      {
                          if ((((3533145086u) % ((u32((resolution[1]), ) - (u32((resolution[0]), ) - ((((u32((dpInput[0][2]), ) + ((4651u) * ((u32((resolution[1]), ) + (11053339u)) - ((4958338u) + u32((dpInput[11][3]), ))) + (((3315726u) + ((1301341u) + (1682351u))) - (6295638u)))) - ((6791745u) + u32((resolution[0]), ))) + u32((dpInput[2][1]), )) - ((2356084u) * (6u) + ((9557u) + ((4901u) * (3u) + (3984u)) * (4u)))))) * ((1699684u) + u32((resolution[0]), )) + ((91987u) + (178893u) * (u32((dpInput[23][0]), ) - (((14579805u) - (u32((dpInput[22][0]), ) + (u32((dpInput[28][2]), ) + (2562801u)))) + (2609607u) * ((3153644u) - (u32((dpInput[9][1]), ) - (u32((resolution[1]), ) + (8249535u))))))))) > (3030688398u)) || (((canWalk_165) || (dpInput[2][2] <= (((dpInput[3][3]) - (9990389i)) + ((((resolution[0]) + (2562454i)) + ((266812i) + (690774i) * ((resolution[1]) - ((resolution[1]) - ((0i) + (4i)))))) - (5592614i)) * (1776689i)))) || ((canWalk_165) && (((953590229i) / ((4793101i) + ((dpInput[1][3]) - (602153i)))) <= (map_163[121])))))
                          {
                              break;
                          }
                          discard;
                          continuing
                          {
                              break if ((723298395u) >= (firstLeadingBit((dot4U8Packed((319687079u), (extractBits((2138067306u), (u32((resolution[0]), ) - (u32((resolution[1]), ) - (u32((resolution[1]), ) - (248u)))), ((7u) + ((1u) * (1u))), )), )), )));
                          }
                      }
                      direction_167++;
                  }
                  /* dead code fragment: */
                  if (dpInput[1][2] < ((15510379i) - ((dpInput[15][1]) - ((dpInput[5][1]) - ((dpInput[2][0]) - (5723627i))))))
                  {
                      discard;
                  }
                  if (direction_167 == 0)
                  {
                      /* dead code fragment: */
                      if (!(false))
                      {
                      }
                      else
                      {
                          discard;
                      }
                      canWalk_165 = false;
                      /* dead code fragment: */
                      if (!(((16408680i) - ((388572i) + (1536444i))) >= dpInput[13][0]))
                      {
                          discard;
                      }
                      for (var i_162 = 0; i_162 < 8; i_162++)
                      {
                          for (var j_168 = 0; j_168 < 8; j_168++)
                          {
                              /* dead code fragment: */
                              for (; (((resolution[1])) > resolution[1]); )
                              {
                                  discard;
                              }
                              if (map_163[j_168 * 2 + i_162 * 2 * 16] == 0)
                              {
                                  p_164.x = j_168 * 2;
                                  /* dead code fragment: */
                                  if ((((resolution[1]) - (88i)) + ((resolution[1]) - ((resolution[1]) - (((dpInput[16][1]) - (9477248i)) - (680898i))))) != resolution[0])
                                  {
                                      discard;
                                  }
                                  p_164.y = i_162 * 2;
                                  canWalk_165 = true;
                              }
                              /* dead code fragment: */
                              for (; ((((((((2i) * ((1132549i) - (508638i)) + (((resolution[1]) + (((dpInput[0][0]) - (8713666i)) + (1530i))) + (resolution[0]))) + (resolution[0])) + ((dpInput[16][3]) - ((6494498i) - ((((resolution[0]) + ((2i) * (2012700i) + ((resolution[0]) + ((dpInput[25][1]) - (3621565i))))) + (5512869i)) - (7947513i))))) - ((592484i) + (resolution[1]))) + (resolution[0])) < dpInput[23][1]) && (canWalk_165)); )
                              {
                                  discard;
                              }
                          }
                      }
                      /* dead code fragment: */
                      if (resolution[1] >= (((resolution[1]) - ((resolution[0]) - ((resolution[0]) - (((1i) * (6i)) * (29i) + ((((dpInput[6][2]) - ((14090180i) + (resolution[0]))) * (2781264i) + (1987731i)) - (10331503i)))))) + ((dpInput[22][0]) - ((5504654i) + (resolution[1])))))
                      {
                      }
                      else
                      {
                          discard;
                      }
                      map_163[p_164.x + p_164.y * 16] = 1;
                  }
                  else
                  {
                      var d_169 = v_166 % direction_167;
                      /* dead code fragment: */
                      if (dpInput[12][2] <= (((((11101296i) - ((1061998i) + (resolution[1]))) + ((((dpInput[7][3]) - (11461915i)) - (2486839i)) + ((833866i) + (resolution[1])))) - (((((565845i) + ((43544i) + (7i) * ((dpInput[30][3]) - (671610i)))) + ((6i) * ((((6428156i) + (1653104i)) + (4738336i)) - (((10621891i) + (resolution[0])) + (resolution[1]))) + (((resolution[0]) + (3516998i)) - (2096569i)))) - ((dpInput[27][1]) + (49115i))) + (resolution[1]))) * (((dpInput[19][2]) - ((dpInput[19][0]) + (1373055i))) - ((dpInput[21][0]) - (4649916i))) + (((resolution[1]) - (254i)) * (95808i) + ((7047i) * ((resolution[1]) - ((resolution[1]) - ((((resolution[0]) - ((105i) * (2i) + ((dpInput[5][0]) - (5373993i)))) + (((2368970i) + ((7936810i) - (5774644i))) - ((((16595580i) - (((((6212160i) - (5288668i)) + (5i) * ((1891996i) + (resolution[1]))) - ((280670i) + (dpInput[4][1]))) + (11454i))) - (14735504i)) * (8i) + (319080i)))) + (3i)))) + (((1990360i) + (12716894i)) - ((15080916i) - (((resolution[1]) + (6736282i)) - (6357860i))))))))
                      {
                      }
                      else
                      {
                          discard;
                      }
                      v_166 += direction_167;
                      /* dead code fragment: */
                      for (; (!(!(!((!(false)) || ((false) && (false)))))); )
                      {
                          discard;
                      }
                      if (d_169 >= 0 && p_164.x > 0 && map_163[(p_164.x - 2) + p_164.y * 16] == 0)
                      {
                          d_169--;
                          /* dead code fragment: */
                          if (!(((canWalk_165) || (canWalk_165)) && (!(dpInput[31][0] == ((12348198i) - (11365147i))))))
                          {
                          }
                          else
                          {
                              discard;
                          }
                          map_163[p_164.x + p_164.y * 16] = 1;
                          /* dead code fragment: */
                          if (false)
                          {
                              discard;
                          }
                          else
                          {
                          }
                          map_163[(p_164.x - 1) + p_164.y * 16] = 1;
                          /* dead code fragment: */
                          if ((canWalk_165) && ((false) && (!((true) && (false)))))
                          {
                              discard;
                          }
                          else
                          {
                          }
                          map_163[(p_164.x - 2) + p_164.y * 16] = 1;
                          /* dead code fragment: */
                          loop
                          {
                              if (resolution[1] == (((dpInput[26][2]) - ((10972739i) - (617926i))) + ((resolution[1]) - (201i)) * ((dpInput[7][1]) - ((4498807i) + (12147589i)))))
                              {
                                  break;
                              }
                              discard;
                          }
                          p_164.x -= 2;
                      }
                      if (d_169 >= 0 && p_164.y > 0 && map_163[p_164.x + (p_164.y - 2) * 16] == 0)
                      {
                          d_169--;
                          /* dead code fragment: */
                          if (!((true) || ((canWalk_165) || (!((256i) < resolution[1])))))
                          {
                              discard;
                          }
                          else
                          {
                          }
                          map_163[p_164.x + p_164.y * 16] = 1;
                          map_163[p_164.x + (p_164.y - 1) * 16] = 1;
                          map_163[p_164.x + (p_164.y - 2) * 16] = 1;
                          /* dead code fragment: */
                          if (resolution[0] != ((dpInput[13][3]) - (((dpInput[3][3]) + (4914767i)) + (resolution[1]))))
                          {
                              discard;
                          }
                          else
                          {
                          }
                          p_164.y -= 2;
                      }
                      if (d_169 >= 0 && p_164.x < 14 && map_163[(p_164.x + 2) + p_164.y * 16] == 0)
                      {
                          d_169--;
                          /* dead code fragment: */
                          if ((resolution[1] >= (((16462918i) + (resolution[0])) - (16462918i))) || ((insertBits(((firstTrailingBit((v_166), )) % ((592556i) + (((resolution[0]) + ((resolution[0]) + (105702i))) + (125934i) * (5i)))), (num), ((1u) * (u32((resolution[1]), ) - (255u)) + (0u)), ((((13324645u) - (u32((resolution[1]), ) + ((3075678u) + u32((resolution[1]), )))) + ((6352701u) - (1456069u))) - (15145058u)), )) > ((((946662788i) * (ipos_161[1])) / ((dpInput[22][1]) - (5546414i))) & (min((333939789i), (extractBits((-246702946i), (0u), (32u), )), )))))
                          {
                          }
                          else
                          {
                              discard;
                          }
                          map_163[p_164.x + p_164.y * 16] = 1;
                          /* dead code fragment: */
                          if (false)
                          {
                              discard;
                          }
                          else
                          {
                          }
                          map_163[(p_164.x + 1) + p_164.y * 16] = 1;
                          map_163[(p_164.x + 2) + p_164.y * 16] = 1;
                          /* dead code fragment: */
                          for (; (resolution[0] < ((((((resolution[0]) + (3461737i)) + (dpInput[21][1])) - ((resolution[0]) + (1654381i))) - (((dpInput[14][0]) - ((3774225i) + (dpInput[3][0]))) + (resolution[1]))) - (((((dpInput[22][3]) - (6815846i)) * (248414i) + (163832i)) + (dpInput[31][0])) * (3i) + ((resolution[1]) + (1239504i))))); )
                          {
                              discard;
                          }
                          p_164.x += 2;
                      }
                      if (d_169 >= 0 && p_164.y < 14 && map_163[p_164.x + (p_164.y + 2) * 16] == 0)
                      {
                          d_169--;
                          map_163[p_164.x + p_164.y * 16] = 1;
                          /* dead code fragment: */
                          if (((resolution[0]) == ((v_166) + (insertBits((p_164[0]), (-711990364i), (((5357352u) - (5357348u)) * ((1u) + (u32((resolution[1]), ) - (255u))) + ((15401047u) - ((1706415u) + (u32((resolution[0]), ) + ((u32((resolution[1]), ) - (253u)) * ((u32((dpInput[6][3]), ) - (8729826u)) - (6524999u)) + (289441u))) * (((11485u) + (104881u) * (8u)) - (850525u))))), (u32((resolution[1]), ) - (241u)), )))) && ((((767321i) * (9i) + (((3i) * ((7722i) * ((dpInput[25][3]) - (8454238i)) + ((306i) + ((dpInput[7][1]) - (16646397i)) * (937i))) + ((dpInput[4][1]) - (8669712i))) + (resolution[0]))) - ((44443i) * ((dpInput[19][2]) - (11337722i)) + ((dpInput[28][0]) - (4235514i)))) > resolution[0]))
                          {
                              discard;
                          }
                          map_163[p_164.x + (p_164.y + 1) * 16] = 1;
                          /* dead code fragment: */
                          loop
                          {
                              if (!(dpInput[30][0] != ((dpInput[13][3]) - ((1638409i) + (dpInput[20][2])))))
                              {
                                  break;
                              }
                              discard;
                          }
                          map_163[p_164.x + (p_164.y + 2) * 16] = 1;
                          p_164.y += 2;
                          /* dead code fragment: */
                          if ((((!(canWalk_165)) || (true)) && ((4162820189u) < (659322367u))) && (!(((extractBits((direction_167), (10u), (u32((resolution[1]), ) - (246u)), )) <= (ipos_161[1])) || (resolution[1] >= (((dpInput[24][1]) - ((((dpInput[3][3]) - ((2779499i) + (7766271i))) + (16037i)) + (4i) * (27306i))) + (126i))))))
                          {
                              discard;
                          }
                      }
                      /* dead code fragment: */
                      while (!(!(dpInput[12][0] != ((dpInput[12][2]) - (3604527i)))))
                      {
                          discard;
                      }
                  }
                  /* dead code fragment: */
                  if (((countLeadingZeros((resolution[1]), )) > (((num) ^ (dpInput[12][3])) | ((dp[40]) / ((((dpInput[20][1]) - (3237826i)) - (7645046i)) + (14782003i))))) && (((((518548i) + ((dpInput[28][2]) - (3614852i)) * (2i)) + (resolution[0])) + (3940929i) * ((resolution[0]) - ((253i) + (0i)))) < dpInput[6][3]))
                  {
                      discard;
                  }
                  if (map_163[ipos_161.y * 16 + ipos_161.x] == 1)
                  {
                      /* dead code fragment: */
                      for (; (false); )
                      {
                          discard;
                      }
                      return (1898916112i);
                  }
                  /* dead code fragment: */
                  while (((firstLeadingBit((dpInput[3][2]), )) <= (i32((2882888781u), ))) && (((firstTrailingBit((p_164[1]), )) >= (countTrailingZeros(((resolution_160[0]) / ((dpInput[10][3]) + (((31000i) + (93277i)) + (2431283i)))), ))) && (!(!(((101i) + (155i)) > resolution[0])))))
                  {
                      discard;
                  }
              }
              return (reverseBits((-1430982500i), ));
          }
          case 9162178, 256, 11038696, 
          {
              /* wrapped original statements: */
      return (num >> 16) & 0xFFFF;
          }
          default
          {
              /* arbitrary compound: */
              let map_209 = array(1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, 1i, );
              let j_210 = (abs((firstLeadingBit(((abs((sign((countLeadingZeros((-434959019i), )), )), )) + (reverseBits((i32((abs((16831998u), )), )), ))), )), ));
              /* dead code fragment: */
              if (!(((countOneBits((((map_209[12]) + (j_210)) ^ ((j_210) % (((7293633i) - ((((3369853i) + (425525i)) + (((434944i) + (979146i)) + (dpInput[30][3]))) - ((dpInput[26][2]) - ((12265597i) - (((12771i) * (3i) + (4217i)) + (6i) * (321407i)))))) + (7746902i)))), )) <= (((-355869896i) & (resolution[1])) % (((6701592i) - (6701565i)) * (497131i) + (406515i)))) && ((((-1457490398i) == (map_209[248])) || ((resolution[1]) != (dp[119]))) && ((256i) > resolution[0]))))
              {
              }
              else
              {
                  discard;
              }
              let i_211 = ((min(((insertBits((resolution[0]), (clamp((dpInput[3][2]), (6186339i), (16150698i), )), (u32((dpInput[18][0]), ) - (((957802u) + (1663422u)) + u32((resolution[0]), ))), (22u), )) & (abs((1994208829i), ))), (-(resolution[0])), )) & (countOneBits((resolution[1]), )));
              /* dead code fragment: */
              if ((!(dpInput[5][0] <= ((12i) * (438646i) + (110287i)))) && (!((((i32((extractBits((3633432413u), (5u), (22u), )), )) <= (i_211)) || ((insertBits((2544860638u), ((countLeadingZeros((countTrailingZeros((504277864u), )), )) - (4134232793u)), (13u), (u32((dpInput[20][1]), ) - (11403428u)), )) != (3884763897u))) && (false))))
              {
                  discard;
              }
              var p_212 = vec2(1i, 1i, );
              /* dead code fragment: */
              if (false)
              {
                  discard;
              }
              else
              {
              }
              var canWalk_213 = (((insertBits((firstLeadingBit((2723625053u), )), (abs((811298270u), )), (2u), ((((4973818u) + (u32((dpInput[26][3]), ) - ((1512218u) + (2u) * ((3962302u) + u32((resolution[1]), )))) * (5370753u)) - (1158724u)) - (14556579u)), )) == ((2511651660u) + (((firstLeadingBit((4069166423u), )) - (max((3303401770u), (1761654891u), ))) / (((60980u) + ((6329u) + (34616u))) + (176484u))))) && ((false) && (false)));
              /* dead code fragment: */
              if (!((resolution[1] == (((dpInput[26][0]) - (9895927i)) + ((dpInput[16][0]) - ((9895721i) + (resolution[1]))))) || ((((extractBits((extractBits((sign((map_209[59]), )), (u32((resolution[1]), ) - (u32((dpInput[2][2]), ) - ((7798698u) - (131113u)))), ((2u) + (5u)), )), (2u), ((13133558u) - (13133529u)), )) & (num)) <= (-252260574i)) || (canWalk_213))))
              {
                  discard;
              }
              if (map_209[j_210 * 2 + i_211 * 2 * 16] == 0)
              {
                  /* dead code fragment: */
                  if ((true) || (((569495323i) ^ (dp[244])) >= (1307968872i)))
                  {
                  }
                  else
                  {
                      discard;
                  }
                  p_212.x = j_210 * 2;
                  /* dead code fragment: */
                  if (resolution[0] <= ((dpInput[20][1]) - (((dpInput[31][0]) - (652392i)) + ((dpInput[13][2]) - (4918497i)))))
                  {
                  }
                  else
                  {
                      discard;
                  }
                  p_212.y = i_211 * 2;
                  /* dead code fragment: */
                  if (!((((2305640i) + ((((9239087i) + (542697i)) + ((dpInput[14][0]) - (11663042i))) - (1798794i))) - ((dpInput[4][0]) - ((13779945i) - (((2247037i) + (dpInput[30][0])) + (resolution[1]))))) != dpInput[9][0]))
                  {
                  }
                  else
                  {
                      discard;
                  }
                  canWalk_213 = true;
                  /* dead code fragment: */
                  while (dpInput[16][3] < (9109650i))
                  {
                      discard;
                  }
              }
          }
      }
      /* control flow wrap return 135: */
      return (resolution[1]);
  }
  
  @fragment
  fn fragmentMain(
      @builtin(position)
      gl_FragCoord : vec4f,
  ) ->
          @location(0)
      vec4f
  {
      for (var i = 0; i < DP_LENGTH / 8; i++)
      {
          let index = 8 * i;
          dp[index] = getBottomHalf(dpInput[i].x, );
          dp[index + 1] = getTopHalf(dpInput[i].x, );
          dp[index + 2] = getBottomHalf(dpInput[i].y, );
          dp[index + 3] = getTopHalf(dpInput[i].y, );
          dp[index + 4] = getBottomHalf(dpInput[i].z, );
          dp[index + 5] = getTopHalf(dpInput[i].z, );
          dp[index + 6] = getBottomHalf(dpInput[i].w, );
          dp[index + 7] = getTopHalf(dpInput[i].w, );
      }
      let pos = gl_FragCoord.xy / vec2<f32>(resolution, );
      let ipos : vec2i = vec2i(pos * vec2(256, 256, ), );
      return trace(ipos, );
  }
  
  `;

      const uniformBuffers = [
        {
          group: 0,
          binding: 0,
          data: [0, 1, 0, 0, 0, 1, 0, 0],
        },
        {
          group: 0,
          binding: 1,
          data: [
            115, 0, 133, 0, 150, 0, 164, 0, 176, 0, 184, 0, 190, 0, 192, 0, 191,
            0, 187, 0, 181, 0, 172, 0, 163, 0, 153, 0, 143, 0, 134, 0, 126, 0,
            120, 0, 116, 0, 114, 0, 114, 0, 117, 0, 121, 0, 127, 0, 134, 0, 141,
            0, 148, 0, 154, 0, 159, 0, 162, 0, 163, 0, 161, 0, 157, 0, 151, 0,
            143, 0, 134, 0, 124, 0, 113, 0, 103, 0, 94, 0, 87, 0, 82, 0, 79, 0,
            80, 0, 84, 0, 91, 0, 101, 0, 114, 0, 130, 0, 146, 0, 164, 0, 182, 0,
            199, 0, 215, 0, 229, 0, 240, 0, 249, 0, 254, 0, 0, 1, 254, 0, 250,
            0, 243, 0, 233, 0, 223, 0, 212, 0, 200, 0, 190, 0, 180, 0, 172, 0,
            166, 0, 163, 0, 161, 0, 162, 0, 164, 0, 169, 0, 174, 0, 179, 0, 185,
            0, 190, 0, 193, 0, 195, 0, 195, 0, 192, 0, 188, 0, 180, 0, 171, 0,
            161, 0, 149, 0, 137, 0, 125, 0, 114, 0, 105, 0, 97, 0, 93, 0, 91, 0,
            93, 0, 98, 0, 106, 0, 117, 0, 130, 0, 145, 0, 161, 0, 177, 0, 193,
            0, 208, 0, 221, 0, 231, 0, 239, 0, 243, 0, 244, 0, 242, 0, 236, 0,
            228, 0, 218, 0, 207, 0, 194, 0, 181, 0, 169, 0, 158, 0, 148, 0, 141,
            0, 135, 0, 132, 0, 131, 0, 132, 0, 135, 0, 138, 0, 143, 0, 147, 0,
            151, 0, 154, 0, 155, 0, 155, 0, 152, 0, 146, 0, 139, 0, 129, 0, 118,
            0, 106, 0, 93, 0, 80, 0, 68, 0, 58, 0, 49, 0, 43, 0, 40, 0, 41, 0,
            44, 0, 51, 0, 61, 0, 73, 0, 87, 0, 103, 0, 119, 0, 134, 0, 149, 0,
            162, 0, 173, 0, 181, 0, 186, 0, 188, 0, 186, 0, 181, 0, 174, 0, 164,
            0, 153, 0, 141, 0, 128, 0, 116, 0, 104, 0, 94, 0, 86, 0, 81, 0, 77,
            0, 76, 0, 77, 0, 80, 0, 84, 0, 89, 0, 94, 0, 98, 0, 102, 0, 104, 0,
            104, 0, 102, 0, 98, 0, 92, 0, 83, 0, 73, 0, 62, 0, 50, 0, 38, 0, 26,
            0, 16, 0, 8, 0, 2, 0, 0, 0, 0, 0, 4, 0, 11, 0, 21, 0, 33, 0, 48, 0,
            64, 0, 81, 0, 98, 0, 114, 0, 129, 0, 141, 0, 151, 0, 158, 0, 161, 0,
            161, 0, 158, 0, 152, 0, 144, 0, 134, 0, 123, 0, 112, 0, 100, 0, 90,
            0, 81, 0, 73, 0, 68, 0, 65, 0, 65, 0, 67, 0, 70, 0, 75, 0, 81, 0,
            87, 0, 92, 0, 97, 0, 101, 0, 103, 0, 102, 0, 100, 0, 95, 0, 88, 0,
            79, 0, 69, 0, 58, 0, 47, 0, 36, 0, 26, 0, 18, 0, 13, 0, 11, 0, 11,
            0, 15, 0, 22, 0, 32, 0, 45, 0, 60, 0, 77, 0, 94, 0,
          ],
        },
      ];

      const job = {
        shaderText,
        uniformBuffers,
      };

      async function main() {
        const result = await executeJob(job, 1);

        console.log(result);

        console.log("Done rendering");
        const doneRenderDiv = document.createElement("div");
        doneRenderDiv.textContent = "Done rendering";
        doneRenderDiv.id = "doneRender";
        document.getElementById("thecanvas").after(doneRenderDiv);
      }

      main();
    </script>
  </body>
</html>
